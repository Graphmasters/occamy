package occamy

import (
	"fmt"
)

// region BasicErr Error

const (
	// ErrInternalHandlerError covers situations where the
	// handler encounters an internal error.
	ErrInternalHandlerError BasicError = "internal_handler_error"

	// ErrTaskInterrupted is exclusively for when a task
	// (generated by a handler) is interrupted by the occamy
	// server through the context being cancelled.
	ErrTaskInterrupted BasicError = "task_interrupted"

	// ErrInvalidBody covers situations where a message
	// was received with invalid bodies.
	ErrInvalidBody BasicError = "invalid_body"

	// ErrInvalidHeader covers situations where a message
	// was received with invalid headers.
	ErrInvalidHeader BasicError = "invalid_headers"

	// ErrInvalidTask covers situations where the task
	// requested is invalid.
	ErrInvalidTask BasicError = "invalid_task"

	// ErrMessageNotAcked is for when the ack method
	// fails for a message.
	ErrMessageNotAcked BasicError = "message_not_acked"

	// ErrMessageNotNacked is for when the nack method
	// fails for a message.
	ErrMessageNotNacked BasicError = "message_not_nacked"

	// ErrTaskNotAdded is exclusively for when a task
	// (generated by a handler) could not be added.
	ErrTaskNotAdded BasicError = "task_not_added"

	// ErrTaskNotKilled is exclusively for when a task
	//	(generated by a handler) could not be killed.
	ErrTaskNotKilled BasicError = "task_not_killed"
)

type BasicError string

func (e BasicError) Error() string {
	return string(e)
}

// endregion

// region Detailed Error

type DetailedError struct {
	BasicErr BasicError
	Cause    string
}

func NewDetailedError(err BasicError, cause string) *DetailedError {
	return &DetailedError{
		BasicErr: err,
		Cause:    cause,
	}
}

func (w *DetailedError) Error() string {
	return fmt.Sprintf("%v: %v", w.BasicErr, w.Cause)
}

// endregion

// region Wrapped Error

type WrappedError struct {
	BasicErr BasicError
	InnerErr error
}

func NewWrappedError(basicErr BasicError, innerErr error) *WrappedError {
	return &WrappedError{
		BasicErr: basicErr,
		InnerErr: innerErr,
	}
}

func (w *WrappedError) Error() string {
	return fmt.Sprintf("%v: %v", w.BasicErr, w.InnerErr)
}

// endregion

// region Error helpers

// extractSimpleError extracts the simple error. The second value returned
// signifies if it was possible/successful. It is only possible when the error
// is one of the local types of errors i.e. BasicError, DetailedError and
// WrappedError.
func extractSimpleError(err error) (BasicError, bool) {
	switch explicitErr := err.(type) {
	case BasicError:
		return explicitErr, true
	case *DetailedError:
		return explicitErr.BasicErr, true
	case *WrappedError:
		return explicitErr.BasicErr, true
	default:
		return "", false
	}
}

// This is expected to be useful later
// nolint
func wrapErrorIfNotLocalError(err error, simpleError BasicError) error {
	if _, ok := extractSimpleError(err); !ok {
		return NewWrappedError(simpleError, err)
	}

	return err
}

func wrapErrorIfNotLocalErrorOrMismatch(err error, expected BasicError) error {
	if actual, ok := extractSimpleError(err); !ok || actual != expected {
		return NewWrappedError(expected, err)
	}

	return err
}

// endregion
