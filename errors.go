package occamy

import (
	"fmt"
)

// region Simple Error

const (
	// ErrInternalHandlerError covers situations where the
	// handler encounters an internal error.
	ErrInternalHandlerError SimpleError = "internal_handler_error"

	// ErrTaskInterrupted is exclusively for when a task
	// (generated by a handler) is interrupted by the occamy
	// server through the context being cancelled.
	ErrTaskInterrupted SimpleError = "task_interrupted"

	// ErrInvalidBody covers situations where a message
	// was received with invalid bodies.
	ErrInvalidBody SimpleError = "invalid_body"

	// ErrInvalidHeader covers situations where a message
	// was received with invalid headers.
	ErrInvalidHeader SimpleError = "invalid_headers"

	// ErrInvalidTask covers situations where the task
	// requested is invalid.
	ErrInvalidTask SimpleError = "invalid_task"

	// ErrMessageNotAcked is for when the ack method
	// fails for a message.
	ErrMessageNotAcked SimpleError = "message_not_acked"

	// ErrMessageNotNacked is for when the nack method
	// fails for a message.
	ErrMessageNotNacked SimpleError = "message_not_nacked"

	// ErrTaskNotAdded is exclusively for when a task
	// (generated by a handler) could not be added.
	ErrTaskNotAdded SimpleError = "task_not_added"

	// ErrTaskNotKilled is exclusively for when a task
	//	(generated by a handler) could not be killed.
	ErrTaskNotKilled SimpleError = "task_not_killed"
)

type SimpleError string

func (e SimpleError) Error() string {
	return string(e)
}

// endregion

// region Detailed Error

type DetailedError struct {
	Simple SimpleError
	Cause  string
}

func NewDetailedError(simple SimpleError, cause string) *DetailedError {
	return &DetailedError{
		Simple: simple,
		Cause:  cause,
	}
}

func (w *DetailedError) Error() string {
	return fmt.Sprintf("%v: %v", w.Simple, w.Cause)
}

// endregion

// region Wrapped Error

type WrappedError struct {
	Simple SimpleError
	Inner  error
}

func NewWrappedError(simple SimpleError, inner error) *WrappedError {
	return &WrappedError{
		Simple: simple,
		Inner:  inner,
	}
}

func (w *WrappedError) Error() string {
	return fmt.Sprintf("%v: %v", w.Simple, w.Inner)
}

// endregion

// region Error helpers

// extractSimpleError extracts the simple error. The second value returned
// signifies if it was possible/successful. It is only possible when the error
// is one of the local types of errors i.e. SimpleError, DetailedError and
// WrappedError.
func extractSimpleError(err error) (SimpleError, bool) {
	switch explicitErr := err.(type) {
	case SimpleError:
		return explicitErr, true
	case *DetailedError:
		return explicitErr.Simple, true
	case *WrappedError:
		return explicitErr.Simple, true
	default:
		return "", false
	}
}

// This is expected to be useful later
// nolint
func wrapErrorIfNotLocalError(err error, simpleError SimpleError) error {
	if _, ok := extractSimpleError(err); !ok {
		return NewWrappedError(simpleError, err)
	}

	return err
}

func wrapErrorIfNotLocalErrorOrMismatch(err error, expected SimpleError) error {
	if actual, ok := extractSimpleError(err); !ok || actual != expected {
		return NewWrappedError(expected, err)
	}

	return err
}

// endregion
